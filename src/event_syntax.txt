####################################################################################################################These are sketches of formal definition of the event tree structure. This write-up shows the thoughts for generatingthe event tree structure, by a series of deductive formal definitions for the relative terms.####################################################################################################################Although events can be considered as continuous stream on the timeline, in practice (computational simulation), we haveto slice (discretize) the events into instantaneous screen shot, so that a (single) event is a collection of orderedinstantaneous slice(s). The boundary between two events is the slice where transition happens.Formal definition of "events":Def1: "Scene", predicate", "argument", "label" and "proposition"Scene: A scene is a conceptual occurrence. The set of scenes are denoted by S.Argumentï¼› An argument is a collection of individuals and categories. Denote the set of all object by A.A k-predicate P is a k-nary (k>=1) map from A^k to a "scene". Normally, we use capitalized letter word to denote a predicate.e.g. EAT( , ) is a 2-predicateA label is either:(1) the name (literally the label) of a predicate, denoted by lower case letters,  e.g. the label of EAT( , ) would be 'eat'.There is a trivial one to one map between of a predicate and its label.(2) the symbol "null", which indicate an empty label.A proposition p is the term of a predicate with all arguments filled up. For example: EAT(John,Burger) is a proposition.Def2: "slice"Let L be the set of labels, then, a slice is a pair (l, t), where l belongs to L, and t is 0 or 1. For slice (l,t). l iscalled the name of the slice, and t is called the state of the slice.Example1:Let 'search','cook','eat' be labels in L, then (cook,1), (eat,0) are slices, (0,cook), (search,2) are not.(null, 0),(null,1) are called empty slice.Plain English: slice is a pair of label and 0-1 state which denote "on-off"".Def3: "simple event"Let G be the set of grounded slice, built on slice set S, an event e is a map from an integer interval [a,b] (b>=a+1)to S, such that,1. e(i) = s, for i in [a, b-1], where s = (l,1) a slice in S2. e(b) = s', such that s' = (l,0)The interval [a,b] is called the period of the simple event, we say the simple event starts at a and ends at b, and b-ais called the length of event e, denoted by len(e). We notice that in a simple event, the slices have the same name l,thus we also call l the name of the event. An empty simple event, is an event whose name is 'null'.Plain English: A simple event is just a sequence of slices aligned in order, where the name of slices are the same, andthe state is always 1 until the last slice (which turn to 0). It describe the start, duration and the end of one simpleaction.Def5: "serial event"For simple events e1, e2, if e1 ends at b and e2 starts at b+1, we say e2 is serial to e1, denoted by e1-e2, (order matters)For simple events e1,...en, n>=2, such that ei-ei+1 for 1<=i<=n-1, and ei with duration [a_i, b_i], we define e, the map from[a1, bn] to S, such that e become ei restricted to [a_i, b_i], denoted be e1e2...en as a series of e1,...en, and call it aserial event, starting at a1, ending at b_n.Plain English, a serial event is just a concatenation of 2 or more simple events.Def6: "parallel event"For simple events e1, e2, if they starts at the same time, then we say e1, e2 parallel, denoted by e1~e2 (order not matter)It is easy to notice that, "~" is transitive. For simple events e1,...en, which parallel, starting at a let b1...b_n be the time they ends.WLOG, we assume b_i<= b_i+1, for all i, We define e, the map from [a,b_n] to union of S^{i}'s, where i goes from 1 to n, such thatfor t in [a,bn], let I(t) be the smallest index i that ei ends not before t, then, e(t) = (en(t),e_n-1(t),...eI(t)(t)), as a parallelevent, starting at a, ending at bn, denoted be [e1,e2,...e_n].Now, we have simple event, serial event and parallel event, which all have a start and an end, therefore we define the tworelations "serial to" and "parallel to" among them similar to those within serial events or paraellel events.And now we recursively define event from simple, serial and parallel events.Def7 "event"(1) Simple events, serial events and parallel events are events.(2) If e1, e2,...e_n are events, and e1-e2,e2-e3,... e_n-1 - e_n then e=e1e2..e_n is an event, we say e is a serial combinationof e1...e_n(3) If e1, e2,...e_n are events, and e1~e2,...~e_n then e=[e1,e2,...e_n] is an event, we say e is a parallel combination of e_1...e_nWith the above definition, we will describe the 'event tree' which is going to be used in creating the world. Beforegiving the description, we first summarize the definition above.We see that with the 7 definitions above, we construct an 'event' from its fundamental elements. The construction can bedivided into to steps:step1: define 'simple event' from more fundamental conceptsstep2: define a general event recursively from simple event by serial or parallel bindings.We talk about these two steps separately.First, we want to reduce whatever events into some irreducible 'atomic' events where we can start our construction. Step2is based on such assumption that there is a bunch of atomic events which can not be further decomposed into sub events.Starting from these 'atomic' events, which we call 'simple event', we recursively define more complex event.How do we construct complex event from simple event? We notice that what ever the event is, as long as it can be decomposed,there are two types of fundamental decompositions: parallel or serial decomposition, that is, a complex event can eitherbe considered as a sequence of smaller events, whose beginnings and ends coincide in order or as a bunch of events thatare bound by beginning, yet are mutually exclusive: that is, only one of the events will finally be carried out.We call the first case 'serial decomposition'. For example, preparing dinner can be parsed into a sequence of washing food,cutting food, and cooking food, a sequence of oredered event carried out one by one. The reverse process of serialdecomposition is 'serial combination', and that is the way we define a serial event from simple events.Similarly, we call the second case 'parallel decomposition'. For example, when preparing dinner, we may decide whetheryou want to cook a beef dish or a chicken dish. In other words, there is a decision to make. And finally, we end up cookingbeef or chicken, that is, there is only going to be one result after the choice is made, but there are multple candidatesbefore that event. In this case, we make a parallel decomposition of the event. And conversely, by assemble the two parallelevents, we get a parallel combination. And that is the logic we define a parallel event from simple events.Once we have parallel events, serial events, and simple events, we can further make arbitrary serial and parallel combinationof these simpler events so that form more complex events, which is the 7th definition: constructing complex event recursively.Now we turn to step1. Remember the whole endeavor of step2 is built on the assumption that there are such atomic events,which can not be further decomposed into smaller events. What are these events? By the theory, they are the smallestevents, but that does not mean that they can not be reduced into smaller structures.Step1 shows how simple events are constructed from more elementary existence. We conceptualize a simple(atomic) event assome label persisting for a period of time. Where the labels have one to one corresponding to some predicates. The predicatesare maps which take arguments are preimage, and the image of such map are something called by 'scene', which is a conceptualoccurrence.For example, 'EAT( , )' 2-predicate, which take 2 argument. Then EAT(A,B) is a scene, which is a conceptual occurence that A eat B.Then we ignore the argument, only take the name of predicate as the symbolic representative of the predicate itself, andmark the predicate by a binary state.The purpose of state marking is that we will put the predicate on a time line. That is, the predicate is performing in acertain period of time (no matter this period is bounded or not). Within the period when it is performing, we have the state'on', and 'off' if not performing. Thus, a certain predicate associate with its 'on-off' state become something relevant,which we call by 'slice'. This is our definition 2.With these setting up, we can define what is an event. Intuitively, an event is a single predicate performing on a consecutiveperiod of time, and we assume the period is finite. In this sense, the event  a continuous line up of certain sliceswhere the slices share their predicate: that is, the same thing happens during the period. Meanwhile, we have to make surethat the event is 'turned on' from beginning all the way until the moment right before it ends. We carve out the durationof the event by align these slice sharing the same predicate: all the slices have state 'on', except for the last slice.Notice that the time line is discrete structure (integer) instead of a mathematical continuous structure like real number.We do this so that the event can be operated in computer simulation.To briefly summarize step1, we build up simple events from scratch, which is a certain predicate functioning on a consecutiveperiod of time.Right now, we don't see why we need a 'on-off' state for a simple event. We see the importance of such design in the complexevents. In a complex event, we stop some sub event and move on to the next sub event. In the realization of such processwe have to know when the precedent event is over, so that we can seek for the next event. One way to know if a event has endedis to stipulate the time it is over, however, when in real operation, we might want to add random factor such that the actualending moment is case sensitive, thus unknown at the begining. In this case, we mark the predicate by a state, once theevent is over we trun off the state switch, otherwise, we keep the switch on. By this desin, the program always know ifan event is over or not, so that it knows what event is being carried out at the moment.With this design, the world knows the current operating event, however, how do the world know which event should be carriedout after the current one get completed? To answer this, we need to have a structure to organize the order of the eventsto be carried out, which is the event tree structure.An event tree is a graphical representation of an event. The basic rule is that, if e is some serial or parallel combinationof events e1...e_n, we denote e and e1,....e_n by nodes, and form a tree structure by connecting e with e1,....e_n.We see that with the rule above, an event can have multiple tree representation, say e= e1e2e3, we can treat e=e1e',where e'=e2e3, thus the tree becomes a binary tree with 3 layers, otherwise, we jujst draw the flat tree by connecting ewith all e1,e2,e3.These differences between these various tree structure seems to be unimportant, however, they are meaningful in the sensethat they parse the events e differently. In the flat representation, there is only two level of events: e and e1,e2,e3;however, in the deeper representation, we group e2 with e3 forming e', in this way, we create a new event e', as anintermediate event structure between the higher structure e and the lower structures e2 and e3.What is the meaning of doing such parsing, thinking of an concrete example of everyday life. Suppose we are parsing theevents we carry out everyday. Let say, in the mornings, we call all things done until arriving at the office by'morning preparation', then we can parse this 'morning preparation' into a sequnce of sub events. The problem is, how fineare we cutting the happenings into pieces? We can cut them into some 'larger' slices like having breakfast and commuting,however, we can further parse the 'commuting' into a sequence of sub events like 'going to the bus stop', 'waiting for bus','riding bus', 'walking to the office', and for each of these sub events, we can further break them up. Now, the 'commuting'becomes that e', and the sub steps like 'riding bus', and 'walking to the office' are like e2, e3 in the example above.Do we keep e' or instead just write it out as the sequnce of e2,e3 and so on? We don't have a standard answer to the question,it depends on the designer's interest. If the designer want there to be an event e' for some emprical reason, we writecreate the e' node, and place it by the side of e1.We see that a certian event can be parsed into multiple tree representation, it is of desinger's interest to decidewhich strucutre is used. However, in general, if without any particular interest, we make the structure as flat aspossible, that is, we don't create intermediate levels if that is not necessary.To creat an event tree is to visualize the serial and parallel structure of an event, if an event can be furtherdecomposed as serial or parallel combination of smaller event, we represent this decomposition by the tree structure,if the sub event obtained can be further decomposed, we continue the tree parsing, until all the leaves of the trees aresimple events (which means they can't be further decomposed).